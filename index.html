<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Kartvaaler – Redigeringsmodus</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>

  <!-- Leaflet.Draw for ruteverktøy + redigering -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <style>
    html, body, #map { height: 100%; margin: 0; }
    /* Topplinje */
    .toolbar { position: fixed; z-index: 1100; top: 10px; left: 10px; display: flex; gap: 8px; background: rgba(255,255,255,0.9); backdrop-filter: blur(6px); border-radius: 12px; padding: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); }
    .toolbar button, .toolbar select, .toolbar input[type="color"] { border: 1px solid #e2e2e2; background: #fff; border-radius: 10px; padding: 8px 10px; font-size: 14px; }
    .toolbar button.primary { background: #0a7cff; color: #fff; border-color: #0a7cff; }

    /* Flytende editorpanel */
    .panel { position: fixed; z-index: 1100; right: 10px; bottom: 10px; width: min(360px, 92vw); max-height: 65vh; overflow: auto; background: rgba(255,255,255,0.98); backdrop-filter: blur(6px); border-radius: 14px; box-shadow: 0 8px 24px rgba(0,0,0,0.2); padding: 12px 14px; display: none; }
    .panel.open { display: block; }
    .panel h3 { margin: 6px 0 10px; }
    .panel label { display:block; font-size: 13px; margin: 8px 0 4px; }
    .panel input[type="text"], .panel textarea, .panel select { width: 100%; box-sizing: border-box; padding: 8px 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px; }
    .panel textarea { min-height: 80px; resize: vertical; }
    .panel .row { display: flex; gap: 8px; }
    .panel .row > * { flex: 1; }
    .panel .actions { display:flex; gap:8px; margin-top:10px; }

    /* Kategori-filter */
    .filters { position: fixed; z-index: 1100; left: 10px; bottom: 10px; background: rgba(255,255,255,0.9); backdrop-filter: blur(6px); border-radius: 12px; padding: 10px; max-width: 70vw; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: none; }
    .filters.open { display:block; }
    .filters h4 { margin: 0 0 6px; }
    .filters .chips { display:flex; flex-wrap: wrap; gap: 6px; }
    .chip { border:1px solid #ddd; border-radius: 999px; padding: 6px 10px; font-size: 13px; cursor: pointer; }
    .chip.active { background:#0a7cff; color:#fff; border-color:#0a7cff; }

    /* Marker-stil */
    .poi-marker { display: grid; place-items: center; }
    .poi-dot { width: 16px; height:16px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 1px 6px rgba(0,0,0,0.35); }

    /* Canvas-warp overlay */
    .turkart-warp { position:absolute; top:0; left:0; pointer-events:none; }

    /* Små varsler øverst (for manglende bilde o.l.) */
    .toast { position:fixed; top:12px; left:50%; transform:translateX(-50%); z-index:1200; background:rgba(20,20,20,0.9); color:#fff; padding:8px 12px; border-radius:10px; box-shadow:0 4px 16px rgba(0,0,0,0.25); font-size:14px; }

    @media (max-width: 720px) { .toolbar { left: 6px; right: 6px; flex-wrap: wrap } }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="toast" class="toast" role="status" aria-live="polite" hidden></div>

  <!-- Topplinje / kontroller -->
  <div class="toolbar" role="toolbar" aria-label="Kartvaaler verktøy">
    <button id="btnEdit" class="primary" title="Slå av/på redigering (E)">✎ Rediger: AV</button>
    <button id="btnAddPoint" title="Legg til punkt (klikk i kartet)">＋ Punkt</button>
    <button id="btnRouteTool" title="Tegn/rediger ruter">Ruteverktøy</button>
    <button id="btnFilters" title="Filtrer kategorier">Filter</button>
    <button id="btnSave" title="Last ned oppdatert pois.json">⬇︎ Lagre fil</button>
    <button id="btnCommit" title="Commit til GitHub med PAT">⬆︎ Commit</button>
  </div>

  <!-- Editorpanel for punkt/rute -->
  <div id="panel" class="panel" aria-live="polite">
    <h3 id="panelTitle">Rediger</h3>
    <div id="panelBody"></div>
    <div class="actions">
      <button id="btnApply" class="primary">Lagre endringer</button>
      <button id="btnDelete">Slett</button>
      <button id="btnClose">Lukk</button>
    </div>
  </div>

  <!-- Kategori-filter -->
  <div id="filters" class="filters">
    <h4>Kategorier</h4>
    <div id="filterChips" class="chips"></div>
  </div>

  <!-- Skjult dialog for GitHub-commit -->
  <dialog id="ghDialog">
    <form method="dialog" id="ghForm" style="min-width: min(560px, 92vw);">
      <h3>Commit til GitHub</h3>
      <p style="margin:6px 0 12px;">Personlig tilgangstoken (PAT) blir <b>kun</b> brukt i denne nettleserøkten og lagres ikke.</p>
      <div class="row">
        <label>Owner
          <input name="owner" type="text" placeholder="jakobsenerik-cloud" required />
        </label>
        <label>Repo
          <input name="repo" type="text" placeholder="kartvaaler" required />
        </label>
      </div>
      <div class="row">
        <label>Branch
          <input name="branch" type="text" value="main" required />
        </label>
        <label>Filsti i repo
          <input name="path" type="text" value="pois.json" required />
        </label>
      </div>
      <div class="row">
        <label>Commit-melding
          <input name="message" type="text" value="Oppdater pois.json via Kartvaaler" required />
        </label>
        <label>PAT
          <input name="token" type="password" placeholder="ghp_..." required />
        </label>
      </div>
      <div class="row">
        <label>Committer navn
          <input name="cname" type="text" value="Kartvaaler" />
        </label>
        <label>Committer e‑post
          <input name="cemail" type="text" value="kartvaaler@example.com" />
        </label>
      </div>
      <menu style="display:flex; gap:8px; justify-content:flex-end; padding: 0;">
        <button value="cancel">Avbryt</button>
        <button value="ok" class="primary">Commit</button>
      </menu>
    </form>
  </dialog>

  <script>
    // ---- Konstanter ----
    const WARP_CORNERS = {
      // WGS84 lat/lng for hver bilde-hjørne (for Turkart.png)
      // Antatt mapping: NW -> bilde (0,0), NE -> (w,0), SE -> (w,h), SW -> (0,h)
      NW: [59.54593535667747, 10.765142440795898],
      NE: [59.539561484456776, 11.201162338256838],
      SE: [59.380786150970934, 11.190948486328127],
      SW: [59.387167906588274, 10.756945610046387]
    };

    // Standardkategorier som alltid skal finnes
    const DEFAULT_CATEGORIES = [ 'Bebyggelse', 'skoler/barnehager', 'naturreservater' ];

    const MAP_CENTER = [59.48, 10.98];
    const MAP_ZOOM = 11;

    let POIData = { points: [], routes: [] };
    const markerIndex = new Map();
    const routeIndex = new Map();

    const btnEdit = document.getElementById('btnEdit');
    const btnAddPoint = document.getElementById('btnAddPoint');
    const btnRouteTool = document.getElementById('btnRouteTool');
    const btnFilters = document.getElementById('btnFilters');
    const btnSave = document.getElementById('btnSave');
    const btnCommit = document.getElementById('btnCommit');
    const panel = document.getElementById('panel');
    const panelBody = document.getElementById('panelBody');
    const panelTitle = document.getElementById('panelTitle');
    const btnApply = document.getElementById('btnApply');
    const btnDelete = document.getElementById('btnDelete');
    const btnClose = document.getElementById('btnClose');
    const filters = document.getElementById('filters');
    const filterChips = document.getElementById('filterChips');
    const ghDialog = document.getElementById('ghDialog');
    const ghForm = document.getElementById('ghForm');

    let editMode = false;
    let addPointPending = false;

    // ---------------- Canvas-warp overlay (prosjektiv) ----------------
    class CanvasWarpOverlay extends L.Layer {
      constructor(url, latlngCorners, options={}) {
        super();
        this._url = url;
        this._corners = latlngCorners; // {NW, NE, SE, SW}
        this.options = Object.assign({ grid: 32, opacity: 0.9 }, options);
        this._img = null;
        this._canvas = null;
        this._ctx = null;
        this._onResize = this._redraw.bind(this);
      }
      onAdd(map) {
        this._map = map;
        this._canvas = L.DomUtil.create('canvas', 'turkart-warp');
        this._ctx = this._canvas.getContext('2d');
        const pane = this._map.getPanes().overlayPane;
        pane.appendChild(this._canvas);
        L.DomEvent.disableClickPropagation(this._canvas);
        this._loadImage().then(()=>{
          this._bind();
          this._redraw();
        });
      }
      onRemove() {
        this._unbind();
        if (this._canvas && this._canvas.parentNode) this._canvas.parentNode.removeChild(this._canvas);
        this._canvas = null; this._ctx = null; this._img = null; this._map = null;
      }
      setOpacity(o){ this.options.opacity = o; this._redraw(); }
      setUrl(u){ this._url = u; this._img = null; this._loadImage().then(()=>this._redraw()); }
      setCorners(latlngCorners){ this._corners = latlngCorners; this._redraw(); }
      _bind(){
        this._map.on('move zoom resize zoomend', this._onResize);
      }
      _unbind(){
        this._map.off('move zoom resize zoomend', this._onResize);
      }
      async _loadImage(){
        if (this._img) return;
        this._img = await new Promise((resolve, reject)=>{
          const im = new Image();
          im.onload = ()=>resolve(im);
          im.onerror = reject;
          im.src = this._url;
        });
      }
      _redraw(){
        if (!this._map || !this._canvas || !this._img) return;
        const size = this._map.getSize();
        if (this._canvas.width !== size.x || this._canvas.height !== size.y) {
          this._canvas.width = size.x; this._canvas.height = size.y;
          this._canvas.style.width = size.x + 'px'; this._canvas.style.height = size.y + 'px';
        }
        const ctx = this._ctx; ctx.clearRect(0,0,this._canvas.width,this._canvas.height); ctx.globalAlpha = this.options.opacity;

        // Prosjektiv homografi fra bilde til skjerm
        const src = [ [0,0], [this._img.width,0], [this._img.width,this._img.height], [0,this._img.height] ];
        const dst = [ 'NW','NE','SE','SW' ].map(k => this._map.latLngToLayerPoint(this._corners[k])).map(p => [p.x, p.y]);
        const H = computeHomography(src, dst);

        // Tegn via triangulert mesh (for å tilnærme projektiv i 2D canvas)
        const grid = this.options.grid;
        for (let i=0;i<grid;i++){
          for (let j=0;j<grid;j++){
            const u0 = i/grid, v0 = j/grid, u1 = (i+1)/grid, v1 = (j+1)/grid;
            // kildepunkter
            const s00 = [u0*this._img.width, v0*this._img.height];
            const s10 = [u1*this._img.width, v0*this._img.height];
            const s11 = [u1*this._img.width, v1*this._img.height];
            const s01 = [u0*this._img.width, v1*this._img.height];
            // dest via homografi
            const d00 = project(H, s00[0], s00[1]);
            const d10 = project(H, s10[0], s10[1]);
            const d11 = project(H, s11[0], s11[1]);
            const d01 = project(H, s01[0], s01[1]);
            // Trekant 1: 00-10-11
            drawAffineTriangle(ctx, this._img,
              s00[0], s00[1], s10[0], s10[1], s11[0], s11[1],
              d00[0], d00[1], d10[0], d10[1], d11[0], d11[1]
            );
            // Trekant 2: 00-11-01
            drawAffineTriangle(ctx, this._img,
              s00[0], s00[1], s11[0], s11[1], s01[0], s01[1],
              d00[0], d00[1], d11[0], d11[1], d01[0], d01[1]
            );
          }
        }
        ctx.globalAlpha = 1;
      }
    }

    function computeHomography(src4, dst4){
      // src4/dst4: [[x,y],... 4 punkter] i rekkefølge: 0->1->2->3 rundt
      const A = [];
      for (let i=0;i<4;i++){
        const [x,y] = src4[i]; const [X,Y] = dst4[i];
        A.push([ x, y, 1, 0, 0, 0, -x*X, -y*X, X ]);
        A.push([ 0, 0, 0, x, y, 1, -x*Y, -y*Y, Y ]);
      }
      // Løs A*h = b via Gauss-Jordan
      const h = solveLinearSystem(A); // length 9, siste skal være 1 etter normalisering
      // Sett sammen 3x3
      return [ [h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],h[8]] ];
    }
    function project(H, x, y){
      const X = H[0][0]*x + H[0][1]*y + H[0][2];
      const Y = H[1][0]*x + H[1][1]*y + H[1][2];
      const W = H[2][0]*x + H[2][1]*y + H[2][2];
      return [ X/W, Y/W ];
    }
    function solveLinearSystem(A){
      // A er 8x9 (16 ligninger, 9 ukjente) – vi løser i minste kvadraters forstand
      // Enkel Gauss-Jordan på normal-likninger A^T A x = A^T b
      const m = A.length; const n = 9; // kolonner
      const AT = Array.from({length:n},()=>Array(m).fill(0));
      for (let i=0;i<m;i++){ for (let j=0;j<n;j++){ AT[j][i] = A[i][j]; } }
      const ATA = Array.from({length:n},()=>Array(n).fill(0));
      const ATb = Array(n).fill(0);
      for (let i=0;i<n;i++){
        for (let j=0;j<n;j++){
          let sum=0; for (let k=0;k<m;k++){ sum += AT[i][k]*A[k][j]; } ATA[i][j]=sum;
        }
        let s=0; for (let k=0;k<m;k++){ s += AT[i][k]*A[k][8]; } ATb[i]=s;
      }
      // Gauss eliminasjon
      const M = ATA.map((row,i)=>row.concat([ATb[i]]));
      for (let i=0;i<n;i++){
        // pivot
        let pivot = M[i][i]; let r=i;
        for (let k=i+1;k<n;k++){ if (Math.abs(M[k][i])>Math.abs(pivot)) { pivot = M[k][i]; r=k; } }
        if (r!==i) { const tmp=M[i]; M[i]=M[r]; M[r]=tmp; }
        if (Math.abs(M[i][i])<1e-12) continue;
        // normaliser
        const div=M[i][i]; for (let j=i;j<=n;j++){ M[i][j]/=div; }
        // eliminer
        for (let k=0;k<n;k++) if (k!==i){ const f=M[k][i]; for (let j=i;j<=n;j++){ M[k][j]-=f*M[i][j]; } }
      }
      const x = M.map(row=>row[n]);
      // normaliser slik at h[8] = 1
      const s = x[8] || 1; return x.map(v=>v/s);
    }
    function drawAffineTriangle(ctx, img,
      sx0,sy0, sx1,sy1, sx2,sy2,
      dx0,dy0, dx1,dy1, dx2,dy2){
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(dx0,dy0); ctx.lineTo(dx1,dy1); ctx.lineTo(dx2,dy2); ctx.closePath();
      ctx.clip();
      // Konstruksjon av transformasjon: unit -> src og unit -> dest
      // Matrise for src
      const denom = (sx0*(sy1-sy2) + sx1*(sy2-sy0) + sx2*(sy0-sy1));
      if (Math.abs(denom) < 1e-8) { ctx.restore(); return; }
      // Affin transformasjon som map'er hele bilde til dest-tri og bruker drawImage
      // Løs via formel M = B * inv(A)
      const A = [ sx1 - sx0, sx2 - sx0, sx0,
                  sy1 - sy0, sy2 - sy0, sy0,
                  0,           0,        1 ];
      const B = [ dx1 - dx0, dx2 - dx0, dx0,
                  dy1 - dy0, dy2 - dy0, dy0,
                  0,           0,        1 ];
      const invA = invert3x3(A);
      if (!invA) { ctx.restore(); return; }
      const M = multiply3x3(B, invA);
      ctx.setTransform(M[0], M[3], M[1], M[4], M[2], M[5]);
      ctx.drawImage(img, 0, 0);
      ctx.restore();
    }
    function invert3x3(m){
      // m som flat 3x3 [a,b,c, d,e,f, g,h,i]
      const a=m[0],b=m[1],c=m[2], d=m[3],e=m[4],f=m[5], g=m[6],h=m[7],i=m[8];
      const A = e*i - f*h; const B = -(d*i - f*g); const C = d*h - e*g;
      const D = -(b*i - c*h); const E = a*i - c*g; const F = -(a*h - b*g);
      const G = b*f - c*e; const H = -(a*f - c*d); const I = a*e - b*d;
      const det = a*A + b*B + c*C; if (Math.abs(det) < 1e-12) return null;
      const inv = [ A/det, D/det, G/det, B/det, E/det, H/det, C/det, F/det, I/det ];
      return inv;
    }
    function multiply3x3(a, b){
      // a,b som flat 3x3, retur flat 3x3
      const r = new Array(9).fill(0);
      r[0]=a[0]*b[0]+a[1]*b[3]+a[2]*b[6];
      r[1]=a[0]*b[1]+a[1]*b[4]+a[2]*b[7];
      r[2]=a[0]*b[2]+a[1]*b[5]+a[2]*b[8];
      r[3]=a[3]*b[0]+a[4]*b[3]+a[5]*b[6];
      r[4]=a[3]*b[1]+a[4]*b[4]+a[5]*b[7];
      r[5]=a[3]*b[2]+a[4]*b[5]+a[5]*b[8];
      r[6]=a[6]*b[0]+a[7]*b[3]+a[8]*b[6];
      r[7]=a[6]*b[1]+a[7]*b[4]+a[8]*b[7];
      r[8]=a[6]*b[2]+a[7]*b[5]+a[8]*b[8];
      return r;
    }

    // ---------------- Kart init + overlay ----------------
    let map;
    function ensureMap() {
      if (window.map instanceof L.Map) {
        map = window.map; // respekter eksisterende oppsett
      } else {
        map = L.map('map', { zoomControl: true, attributionControl: true }).setView(MAP_CENTER, MAP_ZOOM);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> bidragsytere' }).addTo(map);
      }
    }

    let warpOverlay;
    async function findImageUrl() {
      // Tillat ?img=sti eller gjetting av vanlige filnavn/mappeplasseringer
      const urlp = new URLSearchParams(location.search);
      const override = urlp.get('img');
      const candidates = override ? [override] : [
        'Turkart.png','turkart.png','Turkart.PNG','turkart.PNG',
        'Turkart.jpg','turkart.jpg','Turkart.JPG','turkart.JPG',
        'assets/Turkart.png','assets/turkart.png',
        'img/Turkart.png','img/turkart.png'
      ];
      for (const c of candidates) {
        const ok = await new Promise((resolve) => {
          const im = new Image();
          im.onload = () => resolve(true);
          im.onerror = () => resolve(false);
          // cache-busting query for sikkerhets skyld
          im.src = c + (c.includes('?') ? '&' : '?') + 'v=' + Date.now();
        });
        if (ok) return c; // returner original sti uten cache-parameter
      }
      return null;
    }
    function showToast(msg, ms=4000){ const el = document.getElementById('toast'); if (!el) return; el.textContent = msg; el.hidden = false; clearTimeout(showToast._t); showToast._t = setTimeout(()=>{ el.hidden = true; }, ms); }

    async function setupOverlay() {
      const url = await findImageUrl();
      if (!url) { showToast('Fant ikke bildefil (Turkart.*). Legg den ved siden av index.html eller bruk ?img=sti/fil.png'); return; }
      warpOverlay = new CanvasWarpOverlay(url, WARP_CORNERS, { grid: 40, opacity: 0.85 });
      warpOverlay.addTo(map);
    }

    // Lag beholdere for markører og ruter
    const poiLayer = L.featureGroup();
    const routeLayer = L.featureGroup();

    // Leaflet.Draw kontroll (aktiveres/deaktiveres ved behov)
    const drawControl = new L.Control.Draw({ position: 'topleft', draw: { marker: false, rectangle: false, circle: false, circlemarker: false, polygon: false, polyline: { shapeOptions: { weight: 4 }, metric: true, showLength: true } }, edit: { featureGroup: routeLayer, edit: true, remove: true } });
    let drawControlAdded = false;

    function uid(prefix='id') { return `${prefix}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`; }
    function makePOIIcon(color = '#ff3b30') { return L.divIcon({ className: 'poi-marker', iconSize: [18,18], iconAnchor: [9,9], html: `<div class="poi-dot" style="background:${color}"></div>` }); }

    // --- Last inn pois.json ---
    async function loadPOIs() {
      try {
        const res = await fetch('pois.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('Fant ikke pois.json');
        const data = await res.json();
        POIData.points = Array.isArray(data.points) ? data.points : (Array.isArray(data) ? data : []);
        POIData.routes = Array.isArray(data.routes) ? data.routes : [];
      } catch (e) {
        console.warn('Kunne ikke laste pois.json – starter tomt.', e);
        POIData = { points: [], routes: [] };
      }
      renderAll(); buildFilters();
    }

    function renderAll() {
      poiLayer.clearLayers(); routeLayer.clearLayers(); markerIndex.clear(); routeIndex.clear();
      routeLayer.addTo(map); poiLayer.addTo(map);
      for (const r of POIData.routes) {
        const line = L.polyline(r.coords || r.latlngs || [], { color: r.color || '#0a7cff', weight: 4, opacity: 0.9 });
        line.addTo(routeLayer); routeIndex.set(r.id, line); line.on('click', () => openRouteEditor(r.id));
      }
      for (const p of POIData.points) addMarkerToMap(p);
    }
    function addMarkerToMap(p) {
      const m = L.marker([p.lat, p.lng], { icon: makePOIIcon(p.color || '#ff3b30'), draggable: !!editMode }).addTo(poiLayer);
      markerIndex.set(p.id, m); m.bindPopup(makePopupHTML(p));
      m.on('dragend', () => { const latlng = m.getLatLng(); p.lat = latlng.lat; p.lng = latlng.lng; m.setPopupContent(makePopupHTML(p)); });
      m.on('click', () => { if (editMode) openPointEditor(p.id); });
      return m;
    }
    function makePopupHTML(p) { const title = p.title || 'Uten navn'; const desc = p.desc || ''; const cat = p.category || 'ukjent'; return `<div style="min-width:180px"><strong>${escapeHTML(title)}</strong><br/><small>Kategori: ${escapeHTML(cat)}</small>${desc ? `<p style=\"margin:6px 0 0\">${escapeHTML(desc)}</p>` : ''}</div>`; }
    function escapeHTML(str='') { return String(str).replace(/[&<>"']/g, c => ({ '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' }[c])); }

    // --- Redigeringspaneler ---
    let currentEdit = { type: null, id: null };
    function openPointEditor(id) {
      const p = POIData.points.find(x => x.id === id); if (!p) return; currentEdit = { type: 'point', id };
      panelTitle.textContent = 'Rediger punkt';
      const cats = Array.from(new Set([ ...DEFAULT_CATEGORIES, ...POIData.points.map(pp => (pp.category||'').trim()).filter(Boolean) ])).sort((a,b)=>a.localeCompare(b));
      const options = [ `<option value="" ${!p.category? 'selected':''}>— Ingen —</option>`, ...cats.map(c=>`<option value="${escapeHTML(c)}" ${p.category===c?'selected':''}>${escapeHTML(c)}</option>`), `<option value="__new__">+ Ny kategori…</option>`].join('');
      panelBody.innerHTML = `
        <label>Tittel<input id="f_title" type="text" value="${p.title ? escapeHTML(p.title) : ''}" /></label>
        <label>Beskrivelse<textarea id="f_desc">${p.desc ? escapeHTML(p.desc) : ''}</textarea></label>
        <div class="row">
          <label>Farge<input id="f_color" type="color" value="${p.color || '#ff3b30'}" /></label>
          <label>Kategori<select id="f_category">${options}</select></label>
        </div>
        <label id="row_newcat" style="display:none;">Ny kategori<input id="f_category_new" type="text" placeholder="Skriv ny kategori" /></label>
        <div class="row">
          <label>Lat<input id="f_lat" type="text" value="${p.lat}" /></label>
          <label>Lng<input id="f_lng" type="text" value="${p.lng}" /></label>
        </div>`;
      const sel = panelBody.querySelector('#f_category'); const rowNew = panelBody.querySelector('#row_newcat'); sel.addEventListener('change', () => { rowNew.style.display = sel.value === '__new__' ? 'block' : 'none'; });
      panel.classList.add('open');
    }
    function openRouteEditor(id) {
      const r = POIData.routes.find(x => x.id === id); if (!r) return; currentEdit = { type: 'route', id };
      panelTitle.textContent = 'Rediger rute';
      panelBody.innerHTML = `<label>Navn<input id=\"r_name\" type=\"text\" value=\"${r.name ? escapeHTML(r.name) : ''}\" /></label>
        <div class=\"row\"><label>Farge<input id=\"r_color\" type=\"color\" value=\"${r.color || '#0a7cff'}\" /></label>
        <label>Antall punkter<input type=\"text\" value=\"${(r.coords||[]).length}\" disabled /></label></div>`;
      panel.classList.add('open');
    }
    document.getElementById('btnApply').addEventListener('click', () => {
      if (currentEdit.type === 'point') {
        const p = POIData.points.find(x => x.id === currentEdit.id); if (!p) return;
        p.title = panelBody.querySelector('#f_title').value.trim(); p.desc = panelBody.querySelector('#f_desc').value.trim(); p.color = panelBody.querySelector('#f_color').value;
        const catSel = panelBody.querySelector('#f_category').value; p.category = (catSel === '__new__') ? panelBody.querySelector('#f_category_new').value.trim() : catSel.trim();
        p.lat = parseFloat(panelBody.querySelector('#f_lat').value); p.lng = parseFloat(panelBody.querySelector('#f_lng').value);
        const m = markerIndex.get(p.id); if (m) { m.setLatLng([p.lat, p.lng]); m.setIcon(makePOIIcon(p.color || '#ff3b30')); m.setPopupContent(makePopupHTML(p)); }
        buildFilters();
      } else if (currentEdit.type === 'route') {
        const r = POIData.routes.find(x => x.id === currentEdit.id); if (!r) return;
        r.name = panelBody.querySelector('#r_name').value.trim(); r.color = panelBody.querySelector('#r_color').value; const line = routeIndex.get(r.id); if (line) line.setStyle({ color: r.color || '#0a7cff' });
      }
      panel.classList.remove('open');
    });
    document.getElementById('btnDelete').addEventListener('click', () => {
      if (!currentEdit.type) return; if (!confirm('Sikker på at du vil slette?')) return;
      if (currentEdit.type === 'point') {
        const i = POIData.points.findIndex(x => x.id === currentEdit.id); if (i >= 0) POIData.points.splice(i,1);
        const m = markerIndex.get(currentEdit.id); if (m) { poiLayer.removeLayer(m); markerIndex.delete(currentEdit.id); }
      } else if (currentEdit.type === 'route') {
        const i = POIData.routes.findIndex(x => x.id === currentEdit.id); if (i >= 0) POIData.routes.splice(i,1);
        const line = routeIndex.get(currentEdit.id); if (line) { routeLayer.removeLayer(line); routeIndex.delete(currentEdit.id); }
      }
      panel.classList.remove('open');
    });
    document.getElementById('btnClose').addEventListener('click', () => panel.classList.remove('open'));

    // --- Kategorifilter ---
    let activeCats = new Set();
    function buildFilters() {
      const cats = Array.from(new Set([ ...DEFAULT_CATEGORIES, ...POIData.points.map(p => (p.category||'').trim()).filter(Boolean) ])).sort((a,b)=>a.localeCompare(b));
      filterChips.innerHTML = '';
      for (const c of cats) {
        const chip = document.createElement('span'); chip.className = 'chip' + (activeCats.has(c) ? ' active' : ''); chip.textContent = c;
        chip.addEventListener('click', () => { if (activeCats.has(c)) activeCats.delete(c); else activeCats.add(c); chip.classList.toggle('active'); applyFilters(); });
        filterChips.appendChild(chip);
      }
      applyFilters();
    }
    function applyFilters() {
      const showAll = activeCats.size === 0;
      POIData.points.forEach(p => { const m = markerIndex.get(p.id); if (!m) return; const visible = showAll || activeCats.has((p.category||'').trim()); if (visible) m.addTo(poiLayer); else poiLayer.removeLayer(m); });
    }

    // --- Redigeringsmodus ---
    function setEditMode(on) {
      editMode = !!on; btnEdit.textContent = `✎ Rediger: ${editMode ? 'PÅ' : 'AV'}`; btnEdit.classList.toggle('primary', editMode);
      markerIndex.forEach((m) => { if (m.dragging) { editMode ? m.dragging.enable() : m.dragging.disable(); } });
      if (editMode) { if (!drawControlAdded) { map.addControl(drawControl); drawControlAdded = true; } }
      else { if (drawControlAdded) { map.removeControl(drawControl); drawControlAdded = false; } }
    }
    btnEdit.addEventListener('click', () => setEditMode(!editMode));
    window.addEventListener('keydown', (e) => { if (e.key.toLowerCase()==='e') setEditMode(!editMode); });

    // Legg til punkt neste klikk
    btnAddPoint.addEventListener('click', () => { if (!editMode) setEditMode(true); addPointPending = true; btnAddPoint.classList.add('primary'); btnAddPoint.textContent = 'Klikk i kartet…'; });
    btnRouteTool.addEventListener('click', () => { if (!editMode) setEditMode(true); alert('Velg linje‑verktøyet i menyen til venstre for å tegne.'); });

    function onMapClick(e) {
      if (!addPointPending) return; addPointPending = false; btnAddPoint.classList.remove('primary'); btnAddPoint.textContent = '＋ Punkt';
      const p = { id: uid('p'), lat: e.latlng.lat, lng: e.latlng.lng, title: 'Nytt punkt', desc: '', color: '#ff3b30', category: '' };
      POIData.points.push(p); addMarkerToMap(p).openPopup(); openPointEditor(p.id); buildFilters();
    }

    function hookDrawEvents() {
      map.on(L.Draw.Event.CREATED, (evt) => {
        if (evt.layerType === 'polyline') {
          const layer = evt.layer; routeLayer.addLayer(layer);
          const r = { id: uid('r'), name: 'Ny rute', color: '#0a7cff', coords: layer.getLatLngs().map(ll => [ll.lat, ll.lng]) };
          POIData.routes.push(r); routeIndex.set(r.id, layer); layer.setStyle({ color: r.color }); layer.on('click', () => openRouteEditor(r.id)); openRouteEditor(r.id);
        }
      });
      map.on(L.Draw.Event.EDITED, (evt) => { evt.layers.eachLayer((layer) => { for (const [id, l] of routeIndex.entries()) { if (l === layer) { const r = POIData.routes.find(x => x.id === id); if (r) r.coords = layer.getLatLngs().map(ll => [ll.lat, ll.lng]); } } }); });
      map.on(L.Draw.Event.DELETED, (evt) => { evt.layers.eachLayer((layer) => { for (const [id, l] of routeIndex.entries()) { if (l === layer) { const i = POIData.routes.findIndex(x => x.id === id); if (i>=0) POIData.routes.splice(i,1); routeIndex.delete(id); } } }); });
    }

    // Commit og lagre
    btnSave.addEventListener('click', () => { const blob = new Blob([JSON.stringify(POIData, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'pois.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 2000); });
    btnCommit.addEventListener('click', async () => { if (typeof ghDialog.showModal === 'function') ghDialog.showModal(); else alert('Nettleseren din støtter ikke <dialog>. Bruk nedlasting og commit manuelt.'); });
    ghDialog.addEventListener('close', async () => {
      if (ghDialog.returnValue !== 'ok') return; // Avbrutt
      const fd = new FormData(ghForm);
      const owner = fd.get('owner').trim(); const repo = fd.get('repo').trim(); const branch = fd.get('branch').trim(); const path = fd.get('path').trim(); const message = fd.get('message').trim(); const token = fd.get('token').trim(); const cname = fd.get('cname').trim(); const cemail = fd.get('cemail').trim();
      const contentStr = JSON.stringify(POIData, null, 2); const contentB64 = btoa(unescape(encodeURIComponent(contentStr)));
      try {
        const headers = { 'Accept': 'application/vnd.github+json', 'Authorization': `Bearer ${token}` };
        let sha = undefined; const getUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
        const getRes = await fetch(getUrl, { headers }); if (getRes.ok) { const info = await getRes.json(); sha = info.sha; } else if (getRes.status !== 404) { throw new Error(`GET feilet: ${getRes.status}`); }
        const putUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`; const body = { message, content: contentB64, branch };
        if (sha) body.sha = sha; if (cname || cemail) body.committer = { name: cname || 'Kartvaaler', email: cemail || 'kartvaaler@example.com' };
        const putRes = await fetch(putUrl, { method: 'PUT', headers: { ...headers, 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
        if (!putRes.ok) { const t = await putRes.text(); throw new Error(`PUT feilet: ${putRes.status} ${t}`); }
        alert('Commit OK! Oppdater siden for å se endringen i GitHub Pages når den er bygget.');
      } catch (err) { console.error(err); alert('Commit feilet: ' + err.message); }
    });

    // --- Oppstart ---
    async function init() {
      ensureMap();
      await setupOverlay();
      map.on('click', onMapClick);
      hookDrawEvents();
      loadPOIs();
    }
    if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }

    // Eksponer for debugging
    window.Kartvaaler = { get map() { return map; }, POIData, setEditMode, renderAll };
  </script>
</body>
</html>
