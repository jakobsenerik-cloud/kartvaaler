<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Kartvaaler – Safe Warp (GL max-size fix + 2D fallback)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .toolbar { position: fixed; z-index: 1100; top: 10px; left: 10px; display: flex; gap: 8px; background: rgba(255,255,255,.9); padding: 8px; border-radius: 10px; box-shadow: 0 4px 14px rgba(0,0,0,.15); }
    .toolbar button { border: 1px solid #e2e2e2; background: #fff; border-radius: 8px; padding: 8px 10px; cursor: pointer; }
    .toolbar button.primary { background:#0a7cff; color:#fff; border-color:#0a7cff; }
    .status { position: fixed; z-index: 1100; right: 10px; top: 10px; background: rgba(255,255,255,.9); padding: 8px 10px; border-radius: 10px; font: 12px/1.4 system-ui, sans-serif; box-shadow: 0 4px 14px rgba(0,0,0,.15);} 
    .toast { position:fixed; top:12px; left:50%; transform:translateX(-50%); z-index:1200; background:rgba(20,20,20,.9); color:#fff; padding:6px 10px; border-radius:10px; }
    .leaflet-warp2d, .leaflet-warpgl { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="toolbar">
    <button id="btnCalibrate">Kalibrer</button>
    <button id="btnCopyCorners">Kopier hjørner</button>
  </div>
  <div id="status" class="status">Status: …</div>
  <div id="toast" class="toast" hidden></div>

  <script>
    const IMAGE_URL = 'Turkart.png';
    const WARP_CORNERS = {
      NW: [59.54593535667747, 10.765142440795898],
      NE: [59.539561484456776, 11.201162338256838],
      SE: [59.380786150970934, 11.190948486328127],
      SW: [59.387167906588274, 10.756945610046387]
    };
    const MAP_CENTER = [59.48, 10.98];
    const MAP_ZOOM = 11;

    const statusEl = document.getElementById('status');
    function setStatus(msg){ statusEl.textContent = 'Status: ' + msg; }
    function toast(msg, ms=2500){ const t=document.getElementById('toast'); t.textContent=msg; t.hidden=false; clearTimeout(toast._t); toast._t=setTimeout(()=>t.hidden=true, ms); }

    // Leaflet map
    const map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OSM'}).addTo(map);

    // Helpers
    function ll2pt(ll){ return map.latLngToLayerPoint(ll); }

    // 2D Canvas warp (two-triangle technique)
    class Warp2DLayer extends L.Layer{
      constructor(img){ super(); this._img = img; }
      onAdd(map){ this._map=map; this._c = L.DomUtil.create('canvas','leaflet-warp2d'); this._ctx=this._c.getContext('2d'); map.getPanes().overlayPane.appendChild(this._c); this._onMv = this._draw.bind(this); map.on('move zoom viewreset resize', this._onMv); this._resize(); this._draw(); }
      onRemove(map){ map.off('move zoom viewreset resize', this._onMv); this._c.remove(); }
      setCorners(arr){ this._corners = arr; this._draw(); }
      _resize(){ const s=map.getSize(); this._c.width=s.x; this._c.height=s.y; L.DomUtil.setPosition(this._c, L.point(0,0)); }
      _draw(){ if(!this._corners||!this._img.complete) return; this._resize(); const s=map.getSize(); const ctx=this._ctx; ctx.clearRect(0,0,s.x,s.y);
        const p=[ ll2pt(this._corners[0]), ll2pt(this._corners[1]), ll2pt(this._corners[2]), ll2pt(this._corners[3]) ];
        // Draw tri A: (0,0)-(w,0)-(w,h)
        this._drawTri(ctx, [p[0],p[1],p[2]], [0,0, this._img.width,0, this._img.width,this._img.height]);
        // Draw tri B: (0,0)-(w,h)-(0,h)
        this._drawTri(ctx, [p[0],p[2],p[3]], [0,0, this._img.width,this._img.height, 0,this._img.height]);
      }
      _drawTri(ctx, p, t){ // p: [{x,y}*3], t: [sx,sy, sx2,sy2, sx3,sy3]
        ctx.save();
        // Compute affine transform mapping texture triangle t->screen triangle p
        const [x0,y0,x1,y1,x2,y2] = t;
        const [p0,p1,p2] = p;
        const denom = (x0*(y1 - y2) + x1*(y2 - y0) + x2*(y0 - y1)) || 1;
        // Matrix from tex to screen (affine)
        const a = (p0.x*(y1 - y2) + p1.x*(y2 - y0) + p2.x*(y0 - y1)) / denom;
        const b = (p0.y*(y1 - y2) + p1.y*(y2 - y0) + p2.y*(y0 - y1)) / denom;
        const c = (p0.x*(x2 - x1) + p1.x*(x0 - x2) + p2.x*(x1 - x0)) / denom;
        const d = (p0.y*(x2 - x1) + p1.y*(x0 - x2) + p2.y*(x1 - x0)) / denom;
        const e = (p0.x*(x1*y2 - x2*y1) + p1.x*(x2*y0 - x0*y2) + p2.x*(x0*y1 - x1*y0)) / denom;
        const f = (p0.y*(x1*y2 - x2*y1) + p1.y*(x2*y0 - x0*y2) + p2.y*(x0*y1 - x1*y0)) / denom;
        ctx.setTransform(a, b, c, d, e, f);
        // Clip to triangle in screen space to avoid overdraw
        ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.lineTo(x2, y2); ctx.closePath(); ctx.clip();
        ctx.drawImage(this._img, 0, 0); // Uses the transform set above
        ctx.restore();
      }
    }

    // WebGL layer (with MAX_TEXTURE_SIZE downscale)
    class WarpGLLayer extends L.Layer{
      constructor(img){ super(); this._img = img; }
      onAdd(map){ this._map = map; this._canvas = L.DomUtil.create('canvas','leaflet-warpgl'); this._gl = this._canvas.getContext('webgl', { alpha:true, premultipliedAlpha:true, antialias:true });
        map.getPanes().overlayPane.appendChild(this._canvas); this._onMv = this._draw.bind(this); map.on('move zoom viewreset resize', this._onMv); this._resize(); this._initGL(); this._createTexture(); this._draw(); }
      onRemove(map){ map.off('move zoom viewreset resize', this._onMv); this._canvas.remove(); }
      setCorners(arr){ this._corners = arr; this._draw(); }
      _resize(){ const s=map.getSize(); this._canvas.width=s.x; this._canvas.height=s.y; L.DomUtil.setPosition(this._canvas, L.point(0,0)); }
      _initGL(){ const gl=this._gl; if(!gl) throw new Error('WebGL ikke støttet');
        const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, 'attribute vec2 a_pos; attribute vec2 a_tex; varying vec2 v_tex; uniform vec2 u_res; void main(){ vec2 clip=(a_pos/u_res*2.0-1.0)*vec2(1.0,-1.0); gl_Position=vec4(clip,0.0,1.0); v_tex=a_tex; }'); gl.compileShader(vs);
        const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, 'precision mediump float; varying vec2 v_tex; uniform sampler2D u_img; void main(){ gl_FragColor = texture2D(u_img, v_tex); }'); gl.compileShader(fs);
        const prog = gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog); if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error('GL link feilet');
        this._glProg = prog; this._aPos = gl.getAttribLocation(prog,'a_pos'); this._aTex = gl.getAttribLocation(prog,'a_tex'); this._uRes = gl.getUniformLocation(prog,'u_res'); this._uImg = gl.getUniformLocation(prog,'u_img');
        this._posBuf = gl.createBuffer(); this._texBuf = gl.createBuffer(); this._tex = gl.createTexture();
      }
      _createTexture(){ const gl=this._gl; const img=this._img; gl.useProgram(this._glProg); gl.bindTexture(gl.TEXTURE_2D, this._tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        const max = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 4096;
        let src = img; // may be downscaled
        if (img.width > max || img.height > max){
          const scale = Math.min(max/img.width, max/img.height);
          const c=document.createElement('canvas'); c.width=Math.floor(img.width*scale); c.height=Math.floor(img.height*scale);
          const cx=c.getContext('2d'); cx.drawImage(img, 0,0, c.width, c.height); src=c; setStatus(`WebGL: nedskalerte tekstur til ${c.width}x${c.height} (max ${max})`);
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);
      }
      _draw(){ const gl=this._gl; if(!gl||!this._corners) return; const s=map.getSize(); this._resize(); gl.viewport(0,0,this._canvas.width,this._canvas.height); gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT); gl.useProgram(this._glProg);
        const p=[ ll2pt(this._corners[0]), ll2pt(this._corners[1]), ll2pt(this._corners[2]), ll2pt(this._corners[3]) ];
        const pos=new Float32Array([ p[0].x,p[0].y, p[1].x,p[1].y, p[2].x,p[2].y, p[0].x,p[0].y, p[2].x,p[2].y, p[3].x,p[3].y ]);
        const tex=new Float32Array([ 0,0, 1,0, 1,1, 0,0, 1,1, 0,1 ]);
        gl.uniform2f(this._uRes, this._canvas.width, this._canvas.height);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, this._tex); gl.uniform1i(this._uImg, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._posBuf); gl.bufferData(gl.ARRAY_BUFFER, pos, gl.DYNAMIC_DRAW); gl.enableVertexAttribArray(this._aPos); gl.vertexAttribPointer(this._aPos, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texBuf); gl.bufferData(gl.ARRAY_BUFFER, tex, gl.STATIC_DRAW); gl.enableVertexAttribArray(this._aTex); gl.vertexAttribPointer(this._aTex, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
    }

    // Load image and choose best overlay
    const img = new Image();
    img.onload = () => {
      try {
        const gl = document.createElement('canvas').getContext('webgl');
        if (gl) {
          setStatus('Prøver WebGL‑warp');
          const glLayer = new WarpGLLayer(img); glLayer.addTo(map);
          glLayer.setCorners([ WARP_CORNERS.NW, WARP_CORNERS.NE, WARP_CORNERS.SE, WARP_CORNERS.SW ]);
          window._warpLayer = glLayer; window._warpMode = 'webgl';
          setStatus('WebGL‑warp aktiv');
        } else {
          throw new Error('Ingen WebGL');
        }
      } catch (e) {
        console.warn('WebGL feilet, bruker 2D', e);
        setStatus('WebGL feilet – bruker 2D‑warp');
        const c2 = new Warp2DLayer(img); c2.addTo(map);
        c2.setCorners([ WARP_CORNERS.NW, WARP_CORNERS.NE, WARP_CORNERS.SE, WARP_CORNERS.SW ]);
        window._warpLayer = c2; window._warpMode = '2d';
      }
    };
    img.onerror = () => { setStatus('Kunne ikke laste Turkart.png'); toast('Fant ikke Turkart.png i rotmappen'); };
    img.src = IMAGE_URL; // samme opprinnelse – ingen CORS nødvendig

    // Calibration UI (map markers move corners)
    const btnCal = document.getElementById('btnCalibrate');
    const btnCopy = document.getElementById('btnCopyCorners');
    const cornerMarkers = {}; let calOn = false;

    function updateFromMarkers(){ for(const k of ['NW','NE','SE','SW']){ const m=cornerMarkers[k]; if(!m) continue; const ll=m.getLatLng(); WARP_CORNERS[k]=[ll.lat, ll.lng]; }
      const layer = window._warpLayer; if (layer && layer.setCorners) layer.setCorners([ WARP_CORNERS.NW, WARP_CORNERS.NE, WARP_CORNERS.SE, WARP_CORNERS.SW ]);
    }
    function setCal(on){ calOn = (typeof on==='boolean')?on:!calOn; btnCal.classList.toggle('primary', calOn); btnCal.textContent = calOn? 'Kalibrer (PÅ)':'Kalibrer'; if(calOn){
        for (const k of ['NW','NE','SE','SW']){ const m = cornerMarkers[k] || L.marker(WARP_CORNERS[k], { draggable:true, zIndexOffset:900 }).bindTooltip(k, { permanent:true, direction:'top', offset:[0,-12] }); if(!cornerMarkers[k]){ m.on('drag', updateFromMarkers); cornerMarkers[k]=m; } m.setLatLng(WARP_CORNERS[k]).addTo(map).openTooltip(); }
      } else {
        for (const k of Object.keys(cornerMarkers)) try{ map.removeLayer(cornerMarkers[k]); }catch(_){ }
      } updateFromMarkers(); }
    btnCal.addEventListener('click', () => setCal());
    btnCopy.addEventListener('click', async () => { const text = 'WARP_CORNERS = ' + JSON.stringify(WARP_CORNERS, null, 2); try{ await navigator.clipboard.writeText(text); toast('Hjørner kopiert'); } catch(_){ toast('Kopi feilet – marker og kopier manuelt'); } });

    // Expose for quick debug
    window.Kartvaaler = { map, WARP_CORNERS, get warpMode(){return window._warpMode}, get layer(){return window._warpLayer} };
  </script>
</body>
</html>
