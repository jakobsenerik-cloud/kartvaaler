<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>nykart – fri forvrengning uten eksterne plugins</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  html,body{margin:0;height:100%}
  #map{height:100vh;width:100%}
  .panel{position:absolute;z-index:1000;top:10px;left:10px;background:rgba(255,255,255,.97);
    padding:10px 12px;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,.14);
    font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:grid;gap:8px;max-width:780px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  button{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer}
  input[type=range]{width:180px}
  .small{font-size:12px;color:#444}
  .mono{font:12px/1.35 ui-monospace,Consolas,Menlo,monospace;white-space:break-spaces}
  .err{color:#b00020}
</style>
</head>
<body>
<div class="panel">
  <div class="row"><strong>Dra de fire hjørnene (fri forvrengning)</strong> <span class="small">Fil: <b>Turkart.png</b></span></div>
  <div class="row">
    <button id="fitBtn">Vis hele bildet</button>
    <button id="resetBtn">Tilbakestill fra world-fil</button>
    <button id="copyBtn">Kopier hjørner (WGS84)</button>
    <label class="small">Opasitet <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.95"/></label>
    <span id="status" class="small">Laster…</span>
  </div>
  <div id="out" class="mono small"></div>
</div>

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const IMAGE_URL = "Turkart.png?v="+Date.now();
const WORLD_CANDIDATES = ["Turkart.pgw","Turkart.tfw","Turkart.jgw"];

const $ = id => document.getElementById(id);
const status = msg => $('status').innerHTML = msg;

let map, imgEl, imgW=0, imgH=0;
let cornersLL = null; // rekkefølge: NW, NE, SE, SW (latLng)
let markers = {};
let canvasLayer = null;

const GRID_COLS = 24;   // øk for enda glattere warp (24×24 = 1152 trekanter)
const GRID_ROWS = 24;

// ---- UTM32 -> WGS84 (for å lese world-fil) ----
function utmToLatLon(E, N, zone=32, northern=true){
  const a=6378137, f=1/298.257222101, b=a*(1-f);
  const e2=(a*a-b*b)/(a*a), ep2=(a*a-b*b)/(b*b), k0=0.9996;
  const lon0=((zone-1)*6-180+3)*Math.PI/180;
  const x=E-500000, y=northern?N:N-10000000;
  const M=y/k0, mu=M/(a*(1-e2/4-3*e2**2/64-5*e2**3/256));
  const e1=(1-Math.sqrt(1-e2))/(1+Math.sqrt(1-e2));
  const J1=3*e1/2-27*e1**3/32, J2=21*e1**2/16-55*e1**4/32, J3=151*e1**3/96, J4=1097*e1**4/512;
  const fp=mu+J1*Math.sin(2*mu)+J2*Math.sin(4*mu)+J3*Math.sin(6*mu)+J4*Math.sin(8*mu);
  const C1=ep2*Math.cos(fp)**2, T1=Math.tan(fp)**2;
  const N1=a/Math.sqrt(1-e2*Math.sin(fp)**2), R1=N1*(1-e2)/(1-e2*Math.sin(fp)**2);
  const D=x/(N1*k0);
  const lat=fp-(N1*Math.tan(fp)/R1)*((D**2)/2-(5+3*T1+10*C1-4*C1**2-9*ep2)*(D**4)/24+(61+90*T1+298*C1+45*T1**2-252*ep2-3*C1**2)*(D**6)/720);
  const lon=lon0+(D-(1+2*T1+C1)*(D**3)/6+(5-2*C1+28*T1-3*C1**2+8*ep2+24*T1**2)*(D**5)/120)/Math.cos(fp);
  return [lat*180/Math.PI, lon*180/Math.PI];
}

// Les world-fil (TFW/PGW/JGW)
async function loadWorldCorners(){
  for (const name of WORLD_CANDIDATES) {
    try {
      const r = await fetch(name,{cache:'no-store'});
      if (!r.ok) continue;
      const t = (await r.text()).trim().split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      if (t.length < 6) continue;
      const A=+t[0], D=+t[1], B=+t[2], E=+t[3], C=+t[4], F=+t[5];
      const west  = C - A/2;
      const north = F - E/2;       // E < 0
      const east  = west + A*imgW;
      const south = north + E*imgH; // E negativ -> south < north
      const [nwLat,nwLng] = utmToLatLon(west, north);
      const [neLat,neLng] = utmToLatLon(east, north);
      const [seLat,seLng] = utmToLatLon(east, south);
      const [swLat,swLng] = utmToLatLon(west, south);
      return [L.latLng(nwLat,nwLng), L.latLng(neLat,neLng), L.latLng(seLat,seLng), L.latLng(swLat,swLng)];
    } catch {}
  }
  return null;
}

// Marker-stil
function mkIcon(color){
  return L.divIcon({
    className: 'corner-marker',
    html:`<div style="width:14px;height:14px;border-radius:50%;background:${color};
      border:2px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,.3)"></div>`,
    iconSize:[18,18], iconAnchor:[9,9]
  });
}
function addMarkers(){
  const cols = ['#0ea5e9','#22c55e','#ef4444','#f59e0b']; // NW, NE, SE, SW
  const names = ['NW','NE','SE','SW'];
  names.forEach((name,i)=>{
    if (markers[name]) map.removeLayer(markers[name]);
    markers[name] = L.marker(cornersLL[i], { draggable:true, icon:mkIcon(cols[i]), title:name }).addTo(map);
    markers[name].on('drag', ()=>{ cornersLL[i]=markers[name].getLatLng(); requestRender(); });
    markers[name].on('dragend', ()=>{ cornersLL[i]=markers[name].getLatLng(); requestRender(); });
  });
}

// ---- Canvas warp-lag ----
function createCanvasLayer(){
  const pane = map.createPane('warpPane');
  pane.style.zIndex = 400; // over tiles
  const canvas = L.DomUtil.create('canvas','',pane);
  const ctx = canvas.getContext('2d');

  function setCanvasSize(){
    const size = map.getSize();
    canvas.width = size.x;
    canvas.height = size.y;
    const pos = map.containerPointToLayerPoint([0,0]);
    L.DomUtil.setPosition(canvas, pos);
  }

  function latLngToCanvasPoint(ll){
    const p = map.latLngToLayerPoint(ll);
    const topLeft = map.containerPointToLayerPoint([0,0]);
    return { x: p.x - topLeft.x, y: p.y - topLeft.y };
  }

  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerpPt(p,q,t){ return {x: lerp(p.x,q.x,t), y: lerp(p.y,q.y,t)}; }

  // Affin transform fra kilde-triangel (sx,sy) -> dest-triangel (dx,dy)
  function setTriTransform(ctx, s0,s1,s2, d0,d1,d2){
    // Løs M slik at [x y 1]*M = [X Y 1]
    function inv3(m){
      const [a,b,c, d,e,f, g,h,i] = m;
      const A = e*i - f*h, B = c*h - b*i, C = b*f - c/e? (b*f - c*e): (b*f - c*e);
      const D = f*g - d*i, E = a*i - c*g, F = c*d - a*f;
      const G = d*h - e*g, H = b*g - a*h, I = a*e - b*d;
      const det = a*A + b*D + c*G;
      return [
        A/det, B/det, (b*f - c*e)/det,
        D/det, E/det, (c*d - a*f)/det,
        G/det, H/det, I/det
      ];
    }
    // Kilde 3x3
    const Sm = [s0.x,s0.y,1, s1.x,s1.y,1, s2.x,s2.y,1];
    const invS = inv3(Sm);
    // dest-kolonner
    const X = [d0.x,d1.x,d2.x];
    const Y = [d0.y,d1.y,d2.y];
    // Multipliser invS (3x3) med X/Y (3x1)
    function mult3(m, v){ return [
      m[0]*v[0] + m[1]*v[1] + m[2]*v[2],
      m[3]*v[0] + m[4]*v[1] + m[5]*v[2],
      m[6]*v[0] + m[7]*v[1] + m[8]*v[2],
    ]; }
    const tX = mult3(invS, X);
    const tY = mult3(invS, Y);
    // setTransform(a,b,c,d,e,f): [a c e; b d f; 0 0 1]
    ctx.setTransform(tX[0], tY[0], tX[1], tY[1], tX[2], tY[2]);
  }

  function render(){
    setCanvasSize();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.globalAlpha = parseFloat($('opacity').value || '0.95');

    // Hjørner til canvas-punkter (NW,NE,SE,SW)
    const pNW = latLngToCanvasPoint(cornersLL[0]);
    const pNE = latLngToCanvasPoint(cornersLL[1]);
    const pSE = latLngToCanvasPoint(cornersLL[2]);
    const pSW = latLngToCanvasPoint(cornersLL[3]);

    // Bygg bilinear surface og tegn som trekanter
    for (let j=0;j<GRID_ROWS;j++){
      const v0 = j/GRID_ROWS, v1 = (j+1)/GRID_ROWS;
      // kantpunkter for v0/v1
      const L0 = lerpPt(pNW, pSW, v0), R0 = lerpPt(pNE, pSE, v0);
      const L1 = lerpPt(pNW, pSW, v1), R1 = lerpPt(pNE, pSE, v1);

      for (let i=0;i<GRID_COLS;i++){
        const u0 = i/GRID_COLS, u1 = (i+1)/GRID_COLS;

        // dest-hjørner (bilinear interp)
        const Q00 = lerpPt(L0, R0, u0);
        const Q10 = lerpPt(L0, R0, u1);
        const Q01 = lerpPt(L1, R1, u0);
        const Q11 = lerpPt(L1, R1, u1);

        // kilde-hjørner i bildepiksler
        const S00 = {x: u0*imgW, y: v0*imgH};
        const S10 = {x: u1*imgW, y: v0*imgH};
        const S01 = {x: u0*imgW, y: v1*imgH};
        const S11 = {x: u1*imgW, y: v1*imgH};

        // tri 1: (Q00,Q10,Q11) fra (S00,S10,S11)
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(Q00.x,Q00.y); ctx.lineTo(Q10.x,Q10.y); ctx.lineTo(Q11.x,Q11.y); ctx.closePath(); ctx.clip();
        setTriTransform(ctx, S00,S10,S11, Q00,Q10,Q11);
        ctx.drawImage(imgEl, 0, 0);
        ctx.restore();

        // tri 2: (Q00,Q11,Q01) fra (S00,S11,S01)
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(Q00.x,Q00.y); ctx.lineTo(Q11.x,Q11.y); ctx.lineTo(Q01.x,Q01.y); ctx.closePath(); ctx.clip();
        setTriTransform(ctx, S00,S11,S01, Q00,Q11,Q01);
        ctx.drawImage(imgEl, 0, 0);
        ctx.restore();
      }
    }
  }

  const throttled = (()=>{ let raf=null; return ()=>{ if (raf) return; raf=requestAnimationFrame(()=>{ raf=null; render(); }); };})();
  function requestRender(){ throttled(); }

  const layer = {
    onAdd(){
      map.getPanes().overlayPane.appendChild(canvas);
      map.on('move zoom resize', requestRender);
      requestRender();
    },
    onRemove(){
      map.off('move zoom resize', requestRender);
      canvas.remove();
    },
    redraw: requestRender
  };
  return layer;
}

// ---- Helpers/UI ----
function updateOutBox(){
  const names=['NW','NE','SE','SW'];
  const c = cornersLL.map(ll => [ll.lat, ll.lng]);
  $('out').textContent = `${names[0]}: [${c[0][0]}, ${c[0][1]}]
${names[1]}: [${c[1][0]}, ${c[1][1]}]
${names[2]}: [${c[2][0]}, ${c[2][1]}]
${names[3]}: [${c[3][0]}, ${c[3][1]}]`;
}

// ---- Init ----
(async function init(){
  // 1) Last bilde for størrelse
  imgEl = new Image();
  await new Promise((res,rej)=>{ imgEl.onload=()=>res(); imgEl.onerror=()=>rej(new Error("Kunne ikke laste Turkart.png")); imgEl.src=IMAGE_URL; });
  imgW = imgEl.naturalWidth; imgH = imgEl.naturalHeight;

  // 2) Kart
  map = L.map('map');
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
    maxZoom: 19, attribution: '&copy; OpenStreetMap-bidragsytere'
  }).addTo(map);

  // 3) Start-hjørner: world-fil hvis mulig, ellers et grovt felt
  cornersLL = await loadWorldCorners();
  if (!cornersLL){
    cornersLL = [
      L.latLng(59.55, 10.70), // NW
      L.latLng(59.55, 10.90), // NE
      L.latLng(59.45, 10.90), // SE
      L.latLng(59.45, 10.70)  // SW
    ];
    status("Fant ingen world-fil – dra hjørnene til riktig posisjon.");
  } else {
    status("Startet med georeferanse fra world-fil. Dra hjørnene for å finjustere.");
  }

  // 4) Markører og canvas-lag
  addMarkers();
  canvasLayer = createCanvasLayer();
  canvasLayer.onAdd(map);
  map.fitBounds(L.latLngBounds([cornersLL[3], cornersLL[1]]), {padding:[10,10]}); // SW..NE

  // 5) UI
  $('opacity').addEventListener('input', ()=> canvasLayer.redraw());
  $('fitBtn').onclick = ()=> map.fitBounds(L.latLngBounds([cornersLL[3], cornersLL[1]]), {padding:[10,10]});
  $('resetBtn').onclick = async ()=>{
    const c = await loadWorldCorners();
    if (c){ cornersLL = c; Object.values(markers).forEach((m,i)=>m.setLatLng(cornersLL[i])); canvasLayer.redraw(); $('fitBtn').click(); status("Tilbakestilt fra world-fil."); }
    else { status("Ingen world-fil funnet."); }
    updateOutBox();
  };
  $('copyBtn').onclick = ()=>{
    updateOutBox();
    navigator.clipboard?.writeText($('out').textContent).then(()=>status("Hjørner kopiert.")).catch(()=>{});
  };
  updateOutBox();
})();
</script>
</body>
</html>

