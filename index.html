<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Turkart + OSM + LIVE GPS (mobil, rask zoom)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#eaf0f4}
  #ui{position:fixed;z-index:10;top:10px;left:10px;background:rgba(255,255,255,.95);
      padding:8px 10px;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,.12);
      font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  #status{font-size:12px;color:#444}
  input[type=range]{width:120px}
  button{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer}
  #map{position:fixed;inset:0}
  #canvas{position:absolute;left:0;top:0;width:100%;height:100%;touch-action:none}
  /* Markør-overlegg */
  #marker{position:absolute; z-index:3; width:28px; height:28px; transform:translate(-14px,-26px); pointer-events:none}
  #marker svg{display:block}
  #accCircle{position:absolute; z-index:2; border:2px solid rgba(37,99,235,.6); background:rgba(37,99,235,.08); border-radius:50%; transform:translate(-50%,-50%); pointer-events:none}
  /* Attribution */
  #attrib{position:fixed;right:10px;bottom:8px;z-index:5;background:rgba(255,255,255,.9);
          padding:4px 6px;border-radius:6px;font:12px/1.2 system-ui}
  #attrib a{color:#0366d6;text-decoration:none}
</style>
</head>
<body>
  <div id="ui">
    <button id="fitBtn">Vis kartområdet</button>
    <label>Opasitet <input id="opacity" type="range" min="0" max="1" step="0.01" value="0.95"></label>
    <button id="zoomIn">+</button>
    <button id="zoomOut">−</button>
    <button id="zoomFullOut">Zoom ut maks</button>
    <button id="centerMe">Sentrer meg</button>
    <button id="showPosition">Vis min posisjon</button>
    <button id="stopWatch">Stopp</button>
    <span id="status">Laster…</span>
  </div>

  <div id="map">
    <canvas id="canvas"></canvas>
    <div id="marker" hidden>
      <svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg">
        <path d="M14 1 C8 1 4 5.5 4 10.5 c0 6.5 8 13 10 16 2-3 10-9.5 10-16 C24 5.5 20 1 14 1z" fill="#2563eb" stroke="white" stroke-width="2"/>
        <circle cx="14" cy="11" r="4" fill="white"/>
      </svg>
    </div>
    <div id="accCircle" hidden></div>
  </div>

  <div id="attrib">Kartgrunnlag: © <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener">OpenStreetMap-bidragsytere</a></div>

<script>
(function(){
  const IMAGE_URL = "Turkart.png?v=" + Date.now(); // cache-buster
  // Hjørner (WGS84) i rekkefølge: NW, NE, SE, SW
  const CORNERS = [
    [59.54593535667747, 10.765142440795898],
    [59.539561484456776, 11.201162338256838],
    [59.380786150970934, 11.190948486328127],
    [59.387167906588274, 10.756945610046387]
  ];
  // Zoom- og warp-innstillinger
  const MIN_SCALE = 0.01, MAX_SCALE = 8000;
  const GRID_FINE = {cols:24, rows:24};
  const GRID_FAST = {cols:8, rows:8};
  let currentGrid = GRID_FINE;
  const REFINE_DELAY = 140; // ms etter input-stopp før fin tegning

  const R = 6378137, TWO_PI_R = 2*Math.PI*R;

  const statusEl = document.getElementById('status');
  const setStatus = (m)=> statusEl.textContent = m;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', {alpha:false});
  ctx.imageSmoothingEnabled = true; // slås av midlertidig under interaksjon
  const marker = document.getElementById('marker');
  const accCircle = document.getElementById('accCircle');
  const opacityInput = document.getElementById('opacity');

  // Web Mercator
  const toRad = d => d*Math.PI/180;
  const mercXY = (lat, lng)=> {
    const x = R * toRad(lng);
    const y = R * Math.log(Math.tan(Math.PI/4 + toRad(lat)/2));
    return {x,y};
  };
  const cornersM  = CORNERS.map(([lat,lng])=>mercXY(lat,lng));

  let cssW=0, cssH=0;
  let center = {x:0, y:0};
  let scale = 1; // px per meter
  let img = new Image(), imgW=0, imgH=0;

  // ---- Render coalescing ----
  let rafId = null, refineTimer = null;
  function requestRender(){
    if (rafId) return;
    rafId = requestAnimationFrame(()=>{
      rafId = null;
      render();
    });
  }
  function enterFastMode(){
    currentGrid = GRID_FAST;
    ctx.imageSmoothingEnabled = false;
    // ingen refine nå; settes ved scheduleRefine()
  }
  function scheduleRefine(){
    if (refineTimer) clearTimeout(refineTimer);
    refineTimer = setTimeout(()=>{
      currentGrid = GRID_FINE;
      ctx.imageSmoothingEnabled = true;
      requestRender();
    }, REFINE_DELAY);
  }

  function resize(){
    const rect = canvas.getBoundingClientRect();
    cssW = canvas.width = Math.round(rect.width);
    cssH = canvas.height= Math.round(rect.height);
    requestRender();
  }
  new ResizeObserver(resize).observe(document.getElementById('map'));

  function fitView(){
    const xs = cornersM.map(p=>p.x), ys = cornersM.map(p=>p.y);
    const minX=Math.min(...xs), maxX=Math.max(...xs);
    const minY=Math.min(...ys), maxY=Math.max(...ys);
    const pad = 0.08;
    const neededScaleX = (cssW*(1-pad*2)) / (maxX-minX);
    const neededScaleY = (cssH*(1-pad*2)) / (maxY-minY);
    scale = Math.min(neededScaleX, neededScaleY);
    center.x = (minX+maxX)/2;
    center.y = (minY+maxY)/2;
    requestRender();
  }

  const worldToScreen = (mx,my)=>({ x: (mx - center.x)*scale + cssW/2, y: (center.y - my)*scale + cssH/2 });
  const screenToWorld = (sx,sy)=>({ mx: (sx - cssW/2)/scale + center.x, my: center.y - (sy - cssH/2)/scale });

  // --------- OSM tiles ----------
  const tileCache = new Map();
  const tileUrl = (z,x,y)=> `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
  function getTile(z,x,y){
    const n = 1<<z;
    x = ((x % n) + n) % n;
    if (y<0 || y>=n) return null;
    const key = `${z}/${x}/${y}`;
    let im = tileCache.get(key);
    if (!im){
      im = new Image(); im.crossOrigin = "anonymous"; im.src = tileUrl(z,x,y);
      im.onload = ()=>requestRender(); tileCache.set(key, im);
    }
    return im.complete ? im : null;
  }
  function mercToWorldPx(mx,my,z){
    const S = 256 * (1<<z);
    const u = (mx + Math.PI*R) / TWO_PI_R;
    const v = (Math.PI*R - my) / TWO_PI_R;
    return { px: u*S, py: v*S };
  }
  function drawOSM(){
    let z = Math.round(Math.log2(scale * TWO_PI_R / 256));
    z = Math.max(0, Math.min(19, z));
    const S = 256 * (1<<z);
    const mpp = TWO_PI_R / S;
    const spw = scale * mpp;

    const c = mercToWorldPx(center.x, center.y, z);
    const halfW = cssW / spw / 2;
    const halfH = cssH / spw / 2;
    const minPx = c.px - halfW, maxPx = c.px + halfW;
    const minPy = c.py - halfH, maxPy = c.py + halfH;

    const minTx = Math.floor(minPx/256), maxTx = Math.floor(maxPx/256);
    const minTy = Math.floor(minPy/256), maxTy = Math.floor(maxPy/256);

    for (let ty=minTy; ty<=maxTy; ty++){
      for (let tx=minTx; tx<=maxTx; tx++){
        const im = getTile(z, tx, ty);
        if (!im) continue;
        const tilePx = tx*256, tilePy = ty*256;
        const sx = (tilePx - c.px)*spw + cssW/2;
        const sy = (tilePy - c.py)*spw + cssH/2;
        const s = 256*spw;
        ctx.drawImage(im, sx, sy, s, s);
      }
    }
  }

  // --------- Warp av Turkart ----------
  function setTriTransform(ctx, s0,s1,s2, d0,d1,d2){
    const a11=s1.x-s0.x, a12=s2.x-s0.x, a21=s1.y-s0.y, a22=s2.y-s0.y;
    const det=a11*a22-a12*a21; if(Math.abs(det)<1e-12){ctx.setTransform(1,0,0,1,0,0);return;}
    const inv11=a22/det, inv12=-a12/det, inv13=-(inv11*s0.x+inv12*s0.y);
    const inv21=-a21/det, inv22=a11/det, inv23=-(inv21*s0.x+inv22*s0.y);
    const b11=d1.x-d0.x, b12=d2.x-d0.x, b13=d0.x;
    const b21=d1.y-d0.y, b22=d2.y-d0.y, b23=d0.y;
    const A=b11*inv11+b12*inv21, B=b21*inv11+b22*inv21;
    const C=b11*inv12+b12*inv22, D=b21*inv12+b22*inv22;
    const E=b11*inv13+b12*inv23+b13, F=b21*inv13+b22*inv23+b23;
    ctx.setTransform(A,B,C,D,E,F);
  }
  const lerp=(a,b,t)=>a+(b-a)*t;
  const lerpPt=(p,q,t)=>({x:lerp(p.x,q.x,t), y:lerp(p.y,q.y,t)});

  function quadOffscreen(q0,q1,q2,q3){
    const minx = Math.min(q0.x,q1.x,q2.x,q3.x);
    const maxx = Math.max(q0.x,q1.x,q2.x,q3.x);
    const miny = Math.min(q0.y,q1.y,q2.y,q3.y);
    const maxy = Math.max(q0.y,q1.y,q2.y,q3.y);
    return (maxx < 0 || maxy < 0 || minx > cssW || miny > cssH);
  }

  function drawTurkart(){
    if (!img.complete || !imgW) return;
    ctx.save();
    ctx.globalAlpha = parseFloat(opacityInput.value||"0.95");

    const pNW = worldToScreen(cornersM[0].x,cornersM[0].y);
    const pNE = worldToScreen(cornersM[1].x,cornersM[1].y);
    const pSE = worldToScreen(cornersM[2].x,cornersM[2].y);
    const pSW = worldToScreen(cornersM[3].x,cornersM[3].y);

    const COLS = currentGrid.cols, ROWS = currentGrid.rows;

    for(let j=0;j<ROWS;j++){
      const v0=j/ROWS, v1=(j+1)/ROWS;
      const L0=lerpPt(pNW,pSW,v0), R0=lerpPt(pNE,pSE,v0);
      const L1=lerpPt(pNW,pSW,v1), R1=lerpPt(pNE,pSE,v1);

      for(let i=0;i<COLS;i++){
        const u0=i/COLS, u1=(i+1)/COLS;

        const Q00=lerpPt(L0,R0,u0), Q10=lerpPt(L0,R0,u1);
        const Q01=lerpPt(L1,R1,u0), Q11=lerpPt(L1,R1,u1);

        // rask frustum-test: hopp over når helt utenfor skjerm
        if (quadOffscreen(Q00,Q10,Q11,Q01)) continue;

        const S00={x:u0*imgW,y:v0*imgH}, S10={x:u1*imgW,y:v0*imgH};
        const S01={x:u0*imgW,y:v1*imgH}, S11={x:u1*imgW,y:v1*imgH};

        ctx.save();
        ctx.beginPath(); ctx.moveTo(Q00.x,Q00.y); ctx.lineTo(Q10.x,Q10.y); ctx.lineTo(Q11.x,Q11.y); ctx.closePath(); ctx.clip();
        setTriTransform(ctx, S00,S10,S11, Q00,Q10,Q11); ctx.drawImage(img,0,0); ctx.restore();

        ctx.save();
        ctx.beginPath(); ctx.moveTo(Q00.x,Q00.y); ctx.lineTo(Q11.x,Q11.y); ctx.lineTo(Q01.x,Q01.y); ctx.closePath(); ctx.clip();
        setTriTransform(ctx, S00,S11,S01, Q00,Q11,Q01); ctx.drawImage(img,0,0); ctx.restore();
      }
    }
    ctx.restore();
  }

  function render(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,cssW,cssH);
    drawOSM();
    drawTurkart();
    if (lastPos){
      const sp = worldToScreen(lastPos.mx,lastPos.my);
      marker.style.left = sp.x + 'px';
      marker.style.top  = sp.y + 'px';
      marker.hidden = false;
      if (lastPos.acc){
        const pxR = lastPos.acc * scale;
        accCircle.style.width = (pxR*2)+'px';
        accCircle.style.height= (pxR*2)+'px';
        accCircle.style.left = sp.x + 'px';
        accCircle.style.top  = sp.y + 'px';
        accCircle.hidden = false;
      }
    }
  }

  // ---- Gestures: pan, pinch, dbl-tap IN, two-finger tap OUT ----
  let pointers = new Map();
  let isPanning=false, panStartCenter=null, panStartPt=null;
  let pinchStartDist=0, pinchStartScale=1, pinchStartWorld=null, isPinching=false;
  let lastTapTime=0, lastTapPos=null, twoTapTimer=null;

  canvas.addEventListener('pointerdown', e=>{
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (pointers.size===1){
      isPanning = true; enterFastMode();
      panStartCenter = {...center};
      panStartPt = {x:e.clientX, y:e.clientY};
      // dobbelt-trykk IN
      const now = performance.now();
      const pos = {x:e.clientX, y:e.clientY};
      if (now - lastTapTime < 300 && lastTapPos && Math.hypot(pos.x-lastTapPos.x, pos.y-lastTapPos.y) < 40){
        const world = screenToWorld(pos.x, pos.y);
        scale = Math.min(MAX_SCALE, scale * 1.6);
        center.x = world.mx - (pos.x - cssW/2)/scale;
        center.y = (pos.y - cssH/2)/scale + world.my;
        requestRender();
        lastTapTime = 0; lastTapPos = null;
        scheduleRefine();
      } else {
        lastTapTime = now; lastTapPos = pos;
      }
    } else if (pointers.size===2){
      isPinching = true; isPanning=false; enterFastMode();
      const [p1,p2] = [...pointers.values()];
      pinchStartDist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
      pinchStartScale = scale;
      const mid = { x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 };
      pinchStartWorld = screenToWorld(mid.x, mid.y);

      // to-finger tap: zoom UT
      const t = performance.now();
      if (twoTapTimer && (t - twoTapTimer) < 280){
        const world = pinchStartWorld;
        scale = Math.max(MIN_SCALE, scale / 1.6);
        center.x = world.mx - (mid.x - cssW/2)/scale;
        center.y = (mid.y - cssH/2)/scale + world.my;
        requestRender();
        scheduleRefine();
        twoTapTimer = null;
      } else {
        twoTapTimer = t;
      }
    }
  });
  canvas.addEventListener('pointermove', e=>{
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (isPinching && pointers.size>=2){
      const [p1,p2] = [...pointers.values()].slice(0,2);
      const curDist = Math.hypot(p2.x-p1.x, p2.y-p1.y);
      if (pinchStartDist>0){
        scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, pinchStartScale * (curDist/pinchStartDist)));
      }
      const mid = { x:(p1.x+p2.x)/2, y:(p1.y+p2.y)/2 };
      center.x = pinchStartWorld.mx - (mid.x - cssW/2)/scale;
      center.y = (mid.y - cssH/2)/scale + pinchStartWorld.my;
      requestRender();
    } else if (isPanning && pointers.size===1){
      const p = pointers.get(e.pointerId);
      const dx = (p.x - panStartPt.x)/scale;
      const dy = (p.y - panStartPt.y)/scale;
      center.x = panStartCenter.x - dx;
      center.y = panStartCenter.y + dy;
      requestRender();
    }
  });
  function endPointer(e){
    pointers.delete(e.pointerId);
    if (pointers.size<2) isPinching=false;
    if (pointers.size===0){ isPanning=false; }
    scheduleRefine();
  }
  canvas.addEventListener('pointerup', endPointer);
  canvas.addEventListener('pointercancel', endPointer);
  canvas.addEventListener('pointerout', endPointer);
  canvas.addEventListener('pointerleave', endPointer);

  // Mus-hjul zoom (desktop)
  canvas.addEventListener('wheel', e=>{
    e.preventDefault();
    enterFastMode();
    const factor = Math.pow(1.0015, -e.deltaY);
    const pos = {x:e.clientX, y:e.clientY};
    const world = screenToWorld(pos.x, pos.y);
    scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * factor));
    center.x = world.mx - (pos.x - cssW/2)/scale;
    center.y = (pos.y - cssH/2)/scale + world.my;
    requestRender();
    scheduleRefine();
  }, {passive:false});

  // ---- last bildet ----
  img.onload = ()=>{ imgW = img.naturalWidth; imgH = img.naturalHeight; resize(); fitView(); setStatus('Klar'); };
  img.onerror = ()=> setStatus('Klarte ikke å laste Turkart.png (må ligge i samme mappe som index.html)');
  img.src = IMAGE_URL;

  // ---- UI: knapper ----
  document.getElementById('fitBtn').onclick = fitView;
  opacityInput.oninput = ()=> requestRender();

  document.getElementById('zoomIn').onclick  = ()=>{
    enterFastMode();
    const p={x:cssW/2,y:cssH/2}; const w=screenToWorld(p.x,p.y);
    scale = Math.min(MAX_SCALE, scale * 1.3);
    center.x = w.mx - (p.x - cssW/2)/scale;
    center.y = (p.y - cssH/2)/scale + w.my;
    requestRender(); scheduleRefine();
  };
  document.getElementById('zoomOut').onclick = ()=>{
    enterFastMode();
    const p={x:cssW/2,y:cssH/2}; const w=screenToWorld(p.x,p.y);
    scale = Math.max(MIN_SCALE, scale / 1.3);
    center.x = w.mx - (p.x - cssW/2)/scale;
    center.y = (p.y - cssH/2)/scale + w.my;
    requestRender(); scheduleRefine();
  };
  document.getElementById('zoomFullOut').onclick = ()=>{
    enterFastMode();
    const p={x:cssW/2,y:cssH/2}; const w=screenToWorld(p.x,p.y);
    scale = MIN_SCALE;
    center.x = w.mx - (p.x - cssW/2)/scale;
    center.y = (p.y - cssH/2)/scale + w.my;
    requestRender(); scheduleRefine();
  };

  // ---- GPS / dråpe ----
  let watchId=null, lastPos=null;

  function updateMarker(lat,lng,acc){
    const m=mercXY(lat,lng);
    lastPos = {mx:m.x,my:m.y,acc:acc||0};
    requestRender();
  }
  function startWatchPrecise(){
    if (!navigator.geolocation){ setStatus('Geolocation ikke støttet'); return; }
    stopWatch();
    const opts = { enableHighAccuracy:true, timeout:30000, maximumAge:0 };
    marker.hidden = false; accCircle.hidden = false;
    setStatus('Sporer (presis)…');
    watchId = navigator.geolocation.watchPosition(
      pos=>{ updateMarker(pos.coords.latitude,pos.coords.longitude,pos.coords.accuracy);
             setStatus(`Sporer: ${pos.coords.latitude.toFixed(6)}, ${pos.coords.longitude.toFixed(6)} (±${Math.round(pos.coords.accuracy)} m)`); },
      err=>{ const code=({1:'PERMISSION_DENIED',2:'POSITION_UNAVAILABLE',3:'TIMEOUT'})[err.code]||'ERROR';
             setStatus(`Sporing feilet: ${code} – ${err.message}`); },
      opts
    );
  }
  function stopWatch(){ if (watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; } setStatus('Sporing stoppet'); }

  async function centerOnMe(){
    if (lastPos){
      center.x = lastPos.mx; center.y = lastPos.my; requestRender(); scheduleRefine(); return;
    }
    if (!navigator.geolocation){ setStatus('Geolocation ikke støttet'); return; }
    setStatus('Henter posisjon…');
    navigator.geolocation.getCurrentPosition(
      pos => { updateMarker(pos.coords.latitude,pos.coords.longitude,pos.coords.accuracy);
               center.x = lastPos.mx; center.y = lastPos.my; requestRender(); scheduleRefine();
               setStatus(`Posisjon: ${pos.coords.latitude.toFixed(6)}, ${pos.coords.longitude.toFixed(6)} (±${Math.round(pos.coords.accuracy)} m)`); },
      err => { const code=({1:'PERMISSION_DENIED',2:'POSITION_UNAVAILABLE',3:'TIMEOUT'})[err.code]||'ERROR';
               setStatus(`Kunne ikke hente posisjon: ${code} – ${err.message}`); },
      { enableHighAccuracy:true, timeout:15000, maximumAge:0 }
    );
  }

  document.getElementById('centerMe').onclick     = centerOnMe;
  document.getElementById('showPosition').onclick = startWatchPrecise;
  document.getElementById('stopWatch').onclick    = stopWatch;

})();
</script>
</body>
</html>
